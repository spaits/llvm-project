; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 5
; RUN: llc -mtriple arm64-windows -o - %s | FileCheck %s

; struct S { int x; };
; void foo(int n);
; void foo(struct S o);
; void simple_seh() {
;   struct S o;
;
;   __try { foo(o.x); }
;   __finally { foo(o.x); }
; }
; void stack_realign() {
;   struct S __declspec(align(32)) o;
;
;   __try { foo(o.x); }
;   __finally { foo(o.x); }
; }
; void vla_present(int n) {
;   int vla[n];
;
;   __try { foo(n); }
;   __finally { foo(n); }
; }
; void vla_and_realign(int n) {
;   struct S __declspec(align(32)) o;
;   int vla[n];
;
;   __try { foo(o.x); }
;   __finally { foo(o.x); }
; }

%struct.S = type { i32 }

; Test simple SEH (__try/__finally).
define void @simple_seh() #0 personality ptr @__C_specific_handler {
; CHECK-LABEL: simple_seh:
; CHECK:       .Lfunc_begin0:
; CHECK-NEXT:  .seh_proc simple_seh
; CHECK-NEXT:    .seh_handler __C_specific_handler, @unwind, @except
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    sub sp, sp, #48
; CHECK-NEXT:    .seh_stackalloc 48
; CHECK-NEXT:    stp x29, x30, [sp, #16] // 16-byte Folded Spill
; CHECK-NEXT:    .seh_save_fplr 16
; CHECK-NEXT:    add x29, sp, #16
; CHECK-NEXT:    .seh_add_fp 16
; CHECK-NEXT:    .seh_endprologue
; CHECK-NEXT:    mov x0, #-2 // =0xfffffffffffffffe
; CHECK-NEXT:    stur x0, [x29, #16]
; CHECK-NEXT:  .set .Lsimple_seh$frame_escape_0, -8
; CHECK-NEXT:    ldur w0, [x29, #-8]
; CHECK-NEXT:  .Ltmp0:
; CHECK-NEXT:    bl foo
; CHECK-NEXT:  .Ltmp1:
; CHECK-NEXT:    b .LBB0_1
; CHECK-NEXT:  .LBB0_1: // %invoke.cont
; CHECK-NEXT:    uxtb w0, wzr
; CHECK-NEXT:    mov x1, x29
; CHECK-NEXT:    bl fin_simple_seh
; CHECK-NEXT:    .seh_startepilogue
; CHECK-NEXT:    ldp x29, x30, [sp, #16] // 16-byte Folded Reload
; CHECK-NEXT:    .seh_save_fplr 16
; CHECK-NEXT:    add sp, sp, #48
; CHECK-NEXT:    .seh_stackalloc 48
; CHECK-NEXT:    .seh_endepilogue
; CHECK-NEXT:    ret
; CHECK-NEXT:    .seh_endfunclet
; CHECK-NEXT:    .seh_handlerdata
; CHECK-NEXT:    .word (.Llsda_end0-.Llsda_begin0)/16 // Number of call sites
; CHECK-NEXT:  .Llsda_begin0:
; CHECK-NEXT:    .word .Ltmp0@IMGREL // LabelStart
; CHECK-NEXT:    .word .Ltmp1@IMGREL+1 // LabelEnd
; CHECK-NEXT:    .word "?dtor$2@?0?simple_seh@4HA"@IMGREL // FinallyFunclet
; CHECK-NEXT:    .word 0 // Null
; CHECK-NEXT:  .Llsda_end0:
; CHECK-NEXT:    .text
; CHECK-NEXT:    .seh_endproc
; CHECK-NEXT:    .def "?dtor$2@?0?simple_seh@4HA";
; CHECK-NEXT:    .scl 3;
; CHECK-NEXT:    .type 32;
; CHECK-NEXT:    .endef
; CHECK-NEXT:    .p2align 2
; CHECK-NEXT:  "?dtor$2@?0?simple_seh@4HA":
; CHECK-NEXT:  .seh_proc "?dtor$2@?0?simple_seh@4HA"
; CHECK-NEXT:  .LBB0_2: // %ehcleanup
; CHECK-NEXT:    stp x29, x30, [sp, #-16]! // 16-byte Folded Spill
; CHECK-NEXT:    .seh_save_fplr_x 16
; CHECK-NEXT:    .seh_endprologue
; CHECK-NEXT:    mov x29, x1
; CHECK-NEXT:    mov w0, #1 // =0x1
; CHECK-NEXT:    mov x1, x29
; CHECK-NEXT:    bl fin_simple_seh
; CHECK-NEXT:    .seh_startepilogue
; CHECK-NEXT:    ldp x29, x30, [sp], #16 // 16-byte Folded Reload
; CHECK-NEXT:    .seh_save_fplr_x 16
; CHECK-NEXT:    .seh_endepilogue
; CHECK-NEXT:    ret
entry:

  %o = alloca %struct.S, align 8
  call void (...) @llvm.localescape(ptr %o)
  %0 = load i32, ptr %o, align 4
  invoke void @foo(i32 %0) #5
          to label %invoke.cont unwind label %ehcleanup

invoke.cont:                                      ; preds = %entry
  %1 = call ptr @llvm.localaddress()
  call void @fin_simple_seh(i8 0, ptr %1)
  ret void

ehcleanup:                                        ; preds = %entry
  %2 = cleanuppad within none []
  %3 = call ptr @llvm.localaddress()
  call void @fin_simple_seh(i8 1, ptr %3) [ "funclet"(token %2) ]
  cleanupret from %2 unwind to caller
}

define void @fin_simple_seh(i8 %abnormal_termination, ptr %frame_pointer) {
; CHECK-LABEL: fin_simple_seh:
; CHECK:       .seh_proc fin_simple_seh
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    sub sp, sp, #32
; CHECK-NEXT:    .seh_stackalloc 32
; CHECK-NEXT:    str x30, [sp, #16] // 8-byte Folded Spill
; CHECK-NEXT:    .seh_save_reg x30, 16
; CHECK-NEXT:    .seh_endprologue
; CHECK-NEXT:    movz x8, #:abs_g1_s:.Lsimple_seh$frame_escape_0
; CHECK-NEXT:    movk x8, #:abs_g0_nc:.Lsimple_seh$frame_escape_0
; CHECK-NEXT:    strb w0, [sp, #15]
; CHECK-NEXT:    ldr w0, [x1, x8]
; CHECK-NEXT:    str x1, [sp, #24]
; CHECK-NEXT:    bl foo
; CHECK-NEXT:    .seh_startepilogue
; CHECK-NEXT:    ldr x30, [sp, #16] // 8-byte Folded Reload
; CHECK-NEXT:    .seh_save_reg x30, 16
; CHECK-NEXT:    add sp, sp, #32
; CHECK-NEXT:    .seh_stackalloc 32
; CHECK-NEXT:    .seh_endepilogue
; CHECK-NEXT:    ret
; CHECK-NEXT:    .seh_endfunclet
; CHECK-NEXT:    .seh_endproc
entry:

  %frame_pointer.addr = alloca ptr, align 8
  %abnormal_termination.addr = alloca i8, align 1
  %0 = call ptr @llvm.localrecover(ptr @simple_seh, ptr %frame_pointer, i32 0)
  store ptr %frame_pointer, ptr %frame_pointer.addr, align 8
  store i8 %abnormal_termination, ptr %abnormal_termination.addr, align 1
  %1 = load i32, ptr %0, align 4
  call void @foo(i32 %1)
  ret void
}

; Test SEH when stack realignment is needed in case highly aligned stack objects are present.
define void @stack_realign() #0 personality ptr @__C_specific_handler {
; CHECK-LABEL: stack_realign:
; CHECK:       .Lfunc_begin1:
; CHECK-NEXT:  .seh_proc stack_realign
; CHECK-NEXT:    .seh_handler __C_specific_handler, @unwind, @except
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    str x19, [sp, #-48]! // 8-byte Folded Spill
; CHECK-NEXT:    .seh_save_reg_x x19, 48
; CHECK-NEXT:    stp x29, x30, [sp, #8] // 16-byte Folded Spill
; CHECK-NEXT:    .seh_save_fplr 8
; CHECK-NEXT:    add x29, sp, #8
; CHECK-NEXT:    .seh_add_fp 8
; CHECK-NEXT:    .seh_endprologue
; CHECK-NEXT:    sub x9, sp, #16
; CHECK-NEXT:    and sp, x9, #0xffffffffffffffe0
; CHECK-NEXT:    mov x19, sp
; CHECK-NEXT:    mov x0, #-2 // =0xfffffffffffffffe
; CHECK-NEXT:    stur x0, [x29, #24]
; CHECK-NEXT:  .set .Lstack_realign$frame_escape_0, 0
; CHECK-NEXT:    ldr w0, [x19]
; CHECK-NEXT:  .Ltmp2:
; CHECK-NEXT:    bl foo
; CHECK-NEXT:  .Ltmp3:
; CHECK-NEXT:    b .LBB2_1
; CHECK-NEXT:  .LBB2_1: // %invoke.cont
; CHECK-NEXT:    uxtb w0, wzr
; CHECK-NEXT:    mov x1, x19
; CHECK-NEXT:    bl fin_stack_realign
; CHECK-NEXT:    .seh_startepilogue
; CHECK-NEXT:    sub sp, x29, #8
; CHECK-NEXT:    .seh_add_fp 8
; CHECK-NEXT:    ldp x29, x30, [sp, #8] // 16-byte Folded Reload
; CHECK-NEXT:    .seh_save_fplr 8
; CHECK-NEXT:    ldr x19, [sp], #48 // 8-byte Folded Reload
; CHECK-NEXT:    .seh_save_reg_x x19, 48
; CHECK-NEXT:    .seh_endepilogue
; CHECK-NEXT:    ret
; CHECK-NEXT:    .seh_endfunclet
; CHECK-NEXT:    .seh_handlerdata
; CHECK-NEXT:    .word (.Llsda_end1-.Llsda_begin1)/16 // Number of call sites
; CHECK-NEXT:  .Llsda_begin1:
; CHECK-NEXT:    .word .Ltmp2@IMGREL // LabelStart
; CHECK-NEXT:    .word .Ltmp3@IMGREL+1 // LabelEnd
; CHECK-NEXT:    .word "?dtor$2@?0?stack_realign@4HA"@IMGREL // FinallyFunclet
; CHECK-NEXT:    .word 0 // Null
; CHECK-NEXT:  .Llsda_end1:
; CHECK-NEXT:    .text
; CHECK-NEXT:    .seh_endproc
; CHECK-NEXT:    .def "?dtor$2@?0?stack_realign@4HA";
; CHECK-NEXT:    .scl 3;
; CHECK-NEXT:    .type 32;
; CHECK-NEXT:    .endef
; CHECK-NEXT:    .p2align 2
; CHECK-NEXT:  "?dtor$2@?0?stack_realign@4HA":
; CHECK-NEXT:  .seh_proc "?dtor$2@?0?stack_realign@4HA"
; CHECK-NEXT:  .LBB2_2: // %ehcleanup
; CHECK-NEXT:    str x19, [sp, #-32]! // 8-byte Folded Spill
; CHECK-NEXT:    .seh_save_reg_x x19, 32
; CHECK-NEXT:    stp x29, x30, [sp, #8] // 16-byte Folded Spill
; CHECK-NEXT:    .seh_save_fplr 8
; CHECK-NEXT:    .seh_endprologue
; CHECK-NEXT:    mov x29, x1
; CHECK-NEXT:    mov w0, #1 // =0x1
; CHECK-NEXT:    mov x1, x19
; CHECK-NEXT:    bl fin_stack_realign
; CHECK-NEXT:    .seh_startepilogue
; CHECK-NEXT:    ldp x29, x30, [sp, #8] // 16-byte Folded Reload
; CHECK-NEXT:    .seh_save_fplr 8
; CHECK-NEXT:    ldr x19, [sp], #32 // 8-byte Folded Reload
; CHECK-NEXT:    .seh_save_reg_x x19, 32
; CHECK-NEXT:    .seh_endepilogue
; CHECK-NEXT:    ret
entry:

  %o = alloca %struct.S, align 32
  call void (...) @llvm.localescape(ptr %o)
  %0 = load i32, ptr %o, align 32
  invoke void @foo(i32 %0) #5
          to label %invoke.cont unwind label %ehcleanup

invoke.cont:                                      ; preds = %entry
  %1 = call ptr @llvm.localaddress()
  call void @fin_stack_realign(i8 0, ptr %1)
  ret void

ehcleanup:                                        ; preds = %entry
  %2 = cleanuppad within none []
  %3 = call ptr @llvm.localaddress()
  call void @fin_stack_realign(i8 1, ptr %3) [ "funclet"(token %2) ]
  cleanupret from %2 unwind to caller
}

define void @fin_stack_realign(i8 %abnormal_termination, ptr %frame_pointer) {
; CHECK-LABEL: fin_stack_realign:
; CHECK:       .seh_proc fin_stack_realign
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    sub sp, sp, #32
; CHECK-NEXT:    .seh_stackalloc 32
; CHECK-NEXT:    str x30, [sp, #16] // 8-byte Folded Spill
; CHECK-NEXT:    .seh_save_reg x30, 16
; CHECK-NEXT:    .seh_endprologue
; CHECK-NEXT:    movz x8, #:abs_g1_s:.Lstack_realign$frame_escape_0
; CHECK-NEXT:    movk x8, #:abs_g0_nc:.Lstack_realign$frame_escape_0
; CHECK-NEXT:    strb w0, [sp, #15]
; CHECK-NEXT:    ldr w0, [x1, x8]
; CHECK-NEXT:    str x1, [sp, #24]
; CHECK-NEXT:    bl foo
; CHECK-NEXT:    .seh_startepilogue
; CHECK-NEXT:    ldr x30, [sp, #16] // 8-byte Folded Reload
; CHECK-NEXT:    .seh_save_reg x30, 16
; CHECK-NEXT:    add sp, sp, #32
; CHECK-NEXT:    .seh_stackalloc 32
; CHECK-NEXT:    .seh_endepilogue
; CHECK-NEXT:    ret
; CHECK-NEXT:    .seh_endfunclet
; CHECK-NEXT:    .seh_endproc
entry:

  %frame_pointer.addr = alloca ptr, align 8
  %abnormal_termination.addr = alloca i8, align 1
  %0 = call ptr @llvm.localrecover(ptr @stack_realign, ptr %frame_pointer, i32 0)
  store ptr %frame_pointer, ptr %frame_pointer.addr, align 8
  store i8 %abnormal_termination, ptr %abnormal_termination.addr, align 1
  %1 = load i32, ptr %0, align 32
  call void @foo(i32 %1)
  ret void
}

; Test SEH when variable size objects are present on the stack. Note: Escaped vla's are current not supported by SEH.
define void @vla_present(i32 %n) #0 personality ptr @__C_specific_handler {
; CHECK-LABEL: vla_present:
; CHECK:       .Lfunc_begin2:
; CHECK-NEXT:  .seh_proc vla_present
; CHECK-NEXT:    .seh_handler __C_specific_handler, @unwind, @except
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    sub sp, sp, #64
; CHECK-NEXT:    .seh_stackalloc 64
; CHECK-NEXT:    stp x29, x30, [sp, #32] // 16-byte Folded Spill
; CHECK-NEXT:    .seh_save_fplr 32
; CHECK-NEXT:    add x29, sp, #32
; CHECK-NEXT:    .seh_add_fp 32
; CHECK-NEXT:    .seh_endprologue
; CHECK-NEXT:    mov x1, #-2 // =0xfffffffffffffffe
; CHECK-NEXT:    stur x1, [x29, #16]
; CHECK-NEXT:  .set .Lvla_present$frame_escape_0, -4
; CHECK-NEXT:    stur w0, [x29, #-4]
; CHECK-NEXT:    ldur w8, [x29, #-4]
; CHECK-NEXT:    mov x9, sp
; CHECK-NEXT:    stur x9, [x29, #-16]
; CHECK-NEXT:    stur x8, [x29, #-24]
; CHECK-NEXT:    ldur w0, [x29, #-4]
; CHECK-NEXT:  .Ltmp4:
; CHECK-NEXT:    bl foo
; CHECK-NEXT:  .Ltmp5:
; CHECK-NEXT:    b .LBB4_1
; CHECK-NEXT:  .LBB4_1: // %invoke.cont
; CHECK-NEXT:    uxtb w0, wzr
; CHECK-NEXT:    mov x1, x29
; CHECK-NEXT:    bl fin_vla_present
; CHECK-NEXT:    ldur x8, [x29, #-16]
; CHECK-NEXT:    mov sp, x8
; CHECK-NEXT:    .seh_startepilogue
; CHECK-NEXT:    ldp x29, x30, [sp, #32] // 16-byte Folded Reload
; CHECK-NEXT:    .seh_save_fplr 32
; CHECK-NEXT:    add sp, sp, #64
; CHECK-NEXT:    .seh_stackalloc 64
; CHECK-NEXT:    .seh_endepilogue
; CHECK-NEXT:    ret
; CHECK-NEXT:    .seh_endfunclet
; CHECK-NEXT:    .seh_handlerdata
; CHECK-NEXT:    .word (.Llsda_end2-.Llsda_begin2)/16 // Number of call sites
; CHECK-NEXT:  .Llsda_begin2:
; CHECK-NEXT:    .word .Ltmp4@IMGREL // LabelStart
; CHECK-NEXT:    .word .Ltmp5@IMGREL+1 // LabelEnd
; CHECK-NEXT:    .word "?dtor$2@?0?vla_present@4HA"@IMGREL // FinallyFunclet
; CHECK-NEXT:    .word 0 // Null
; CHECK-NEXT:  .Llsda_end2:
; CHECK-NEXT:    .text
; CHECK-NEXT:    .seh_endproc
; CHECK-NEXT:    .def "?dtor$2@?0?vla_present@4HA";
; CHECK-NEXT:    .scl 3;
; CHECK-NEXT:    .type 32;
; CHECK-NEXT:    .endef
; CHECK-NEXT:    .p2align 2
; CHECK-NEXT:  "?dtor$2@?0?vla_present@4HA":
; CHECK-NEXT:  .seh_proc "?dtor$2@?0?vla_present@4HA"
; CHECK-NEXT:  .LBB4_2: // %ehcleanup
; CHECK-NEXT:    stp x29, x30, [sp, #-16]! // 16-byte Folded Spill
; CHECK-NEXT:    .seh_save_fplr_x 16
; CHECK-NEXT:    .seh_endprologue
; CHECK-NEXT:    mov x29, x1
; CHECK-NEXT:    mov w0, #1 // =0x1
; CHECK-NEXT:    mov x1, x29
; CHECK-NEXT:    bl fin_vla_present
; CHECK-NEXT:    .seh_startepilogue
; CHECK-NEXT:    ldp x29, x30, [sp], #16 // 16-byte Folded Reload
; CHECK-NEXT:    .seh_save_fplr_x 16
; CHECK-NEXT:    .seh_endepilogue
; CHECK-NEXT:    ret
entry:

  %n.addr = alloca i32, align 4
  %saved_stack = alloca ptr, align 8
  %__vla_expr0 = alloca i64, align 8
  call void (...) @llvm.localescape(ptr %n.addr)
  store i32 %n, ptr %n.addr, align 4
  %0 = load i32, ptr %n.addr, align 4
  %1 = zext i32 %0 to i64
  %2 = call ptr @llvm.stacksave()
  store ptr %2, ptr %saved_stack, align 8
  %vla = alloca i32, i64 %1, align 4
  store i64 %1, ptr %__vla_expr0, align 8
  %3 = load i32, ptr %n.addr, align 4
  invoke void @foo(i32 %3) #5
          to label %invoke.cont unwind label %ehcleanup

invoke.cont:                                      ; preds = %entry
  %4 = call ptr @llvm.localaddress()
  call void @fin_vla_present(i8 0, ptr %4)
  %5 = load ptr, ptr %saved_stack, align 8
  call void @llvm.stackrestore(ptr %5)
  ret void

ehcleanup:                                        ; preds = %entry
  %6 = cleanuppad within none []
  %7 = call ptr @llvm.localaddress()
  call void @fin_vla_present(i8 1, ptr %7) [ "funclet"(token %6) ]
  cleanupret from %6 unwind to caller
}

define void @fin_vla_present(i8 %abnormal_termination, ptr %frame_pointer) {
; CHECK-LABEL: fin_vla_present:
; CHECK:       .seh_proc fin_vla_present
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    sub sp, sp, #32
; CHECK-NEXT:    .seh_stackalloc 32
; CHECK-NEXT:    str x30, [sp, #16] // 8-byte Folded Spill
; CHECK-NEXT:    .seh_save_reg x30, 16
; CHECK-NEXT:    .seh_endprologue
; CHECK-NEXT:    movz x8, #:abs_g1_s:.Lvla_present$frame_escape_0
; CHECK-NEXT:    movk x8, #:abs_g0_nc:.Lvla_present$frame_escape_0
; CHECK-NEXT:    strb w0, [sp, #15]
; CHECK-NEXT:    ldr w0, [x1, x8]
; CHECK-NEXT:    str x1, [sp, #24]
; CHECK-NEXT:    bl foo
; CHECK-NEXT:    .seh_startepilogue
; CHECK-NEXT:    ldr x30, [sp, #16] // 8-byte Folded Reload
; CHECK-NEXT:    .seh_save_reg x30, 16
; CHECK-NEXT:    add sp, sp, #32
; CHECK-NEXT:    .seh_stackalloc 32
; CHECK-NEXT:    .seh_endepilogue
; CHECK-NEXT:    ret
; CHECK-NEXT:    .seh_endfunclet
; CHECK-NEXT:    .seh_endproc
entry:

  %frame_pointer.addr = alloca ptr, align 8
  %abnormal_termination.addr = alloca i8, align 1
  %0 = call ptr @llvm.localrecover(ptr @vla_present, ptr %frame_pointer, i32 0)
  store ptr %frame_pointer, ptr %frame_pointer.addr, align 8
  store i8 %abnormal_termination, ptr %abnormal_termination.addr, align 1
  %1 = load i32, ptr %0, align 4
  call void @foo(i32 %1)
  ret void
}

; Test when both vla's and highly aligned objects are present on stack.
define void @vla_and_realign(i32 %n) #0 personality ptr @__C_specific_handler {
; CHECK-LABEL: vla_and_realign:
; CHECK:       .Lfunc_begin3:
; CHECK-NEXT:  .seh_proc vla_and_realign
; CHECK-NEXT:    .seh_handler __C_specific_handler, @unwind, @except
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    str x19, [sp, #-48]! // 8-byte Folded Spill
; CHECK-NEXT:    .seh_save_reg_x x19, 48
; CHECK-NEXT:    stp x29, x30, [sp, #8] // 16-byte Folded Spill
; CHECK-NEXT:    .seh_save_fplr 8
; CHECK-NEXT:    add x29, sp, #8
; CHECK-NEXT:    .seh_add_fp 8
; CHECK-NEXT:    .seh_endprologue
; CHECK-NEXT:    sub x9, sp, #48
; CHECK-NEXT:    and sp, x9, #0xffffffffffffffe0
; CHECK-NEXT:    mov x19, sp
; CHECK-NEXT:    mov x1, #-2 // =0xfffffffffffffffe
; CHECK-NEXT:    stur x1, [x29, #24]
; CHECK-NEXT:  .set .Lvla_and_realign$frame_escape_0, 32
; CHECK-NEXT:    str w0, [x29, #36]
; CHECK-NEXT:    ldr w8, [x29, #36]
; CHECK-NEXT:    mov x9, sp
; CHECK-NEXT:    str x9, [x29, #16]
; CHECK-NEXT:    str x8, [x19, #24]
; CHECK-NEXT:    ldr w0, [x19, #32]
; CHECK-NEXT:  .Ltmp6:
; CHECK-NEXT:    bl foo
; CHECK-NEXT:  .Ltmp7:
; CHECK-NEXT:    b .LBB6_1
; CHECK-NEXT:  .LBB6_1: // %invoke.cont
; CHECK-NEXT:    uxtb w0, wzr
; CHECK-NEXT:    mov x1, x19
; CHECK-NEXT:    bl fin_vla_and_realign
; CHECK-NEXT:    ldr x8, [x29, #16]
; CHECK-NEXT:    mov sp, x8
; CHECK-NEXT:    .seh_startepilogue
; CHECK-NEXT:    sub sp, x29, #8
; CHECK-NEXT:    .seh_add_fp 8
; CHECK-NEXT:    ldp x29, x30, [sp, #8] // 16-byte Folded Reload
; CHECK-NEXT:    .seh_save_fplr 8
; CHECK-NEXT:    ldr x19, [sp], #48 // 8-byte Folded Reload
; CHECK-NEXT:    .seh_save_reg_x x19, 48
; CHECK-NEXT:    .seh_endepilogue
; CHECK-NEXT:    ret
; CHECK-NEXT:    .seh_endfunclet
; CHECK-NEXT:    .seh_handlerdata
; CHECK-NEXT:    .word (.Llsda_end3-.Llsda_begin3)/16 // Number of call sites
; CHECK-NEXT:  .Llsda_begin3:
; CHECK-NEXT:    .word .Ltmp6@IMGREL // LabelStart
; CHECK-NEXT:    .word .Ltmp7@IMGREL+1 // LabelEnd
; CHECK-NEXT:    .word "?dtor$2@?0?vla_and_realign@4HA"@IMGREL // FinallyFunclet
; CHECK-NEXT:    .word 0 // Null
; CHECK-NEXT:  .Llsda_end3:
; CHECK-NEXT:    .text
; CHECK-NEXT:    .seh_endproc
; CHECK-NEXT:    .def "?dtor$2@?0?vla_and_realign@4HA";
; CHECK-NEXT:    .scl 3;
; CHECK-NEXT:    .type 32;
; CHECK-NEXT:    .endef
; CHECK-NEXT:    .p2align 2
; CHECK-NEXT:  "?dtor$2@?0?vla_and_realign@4HA":
; CHECK-NEXT:  .seh_proc "?dtor$2@?0?vla_and_realign@4HA"
; CHECK-NEXT:  .LBB6_2: // %ehcleanup
; CHECK-NEXT:    str x19, [sp, #-32]! // 8-byte Folded Spill
; CHECK-NEXT:    .seh_save_reg_x x19, 32
; CHECK-NEXT:    stp x29, x30, [sp, #8] // 16-byte Folded Spill
; CHECK-NEXT:    .seh_save_fplr 8
; CHECK-NEXT:    .seh_endprologue
; CHECK-NEXT:    mov x29, x1
; CHECK-NEXT:    mov w0, #1 // =0x1
; CHECK-NEXT:    mov x1, x19
; CHECK-NEXT:    bl fin_vla_and_realign
; CHECK-NEXT:    .seh_startepilogue
; CHECK-NEXT:    ldp x29, x30, [sp, #8] // 16-byte Folded Reload
; CHECK-NEXT:    .seh_save_fplr 8
; CHECK-NEXT:    ldr x19, [sp], #32 // 8-byte Folded Reload
; CHECK-NEXT:    .seh_save_reg_x x19, 32
; CHECK-NEXT:    .seh_endepilogue
; CHECK-NEXT:    ret
entry:

  %n.addr = alloca i32, align 4
  %o = alloca %struct.S, align 32
  %saved_stack = alloca ptr, align 8
  %__vla_expr0 = alloca i64, align 8
  call void (...) @llvm.localescape(ptr %o)
  store i32 %n, ptr %n.addr, align 4
  %0 = load i32, ptr %n.addr, align 4
  %1 = zext i32 %0 to i64
  %2 = call ptr @llvm.stacksave()
  store ptr %2, ptr %saved_stack, align 8
  %vla = alloca i32, i64 %1, align 4
  store i64 %1, ptr %__vla_expr0, align 8
  %3 = load i32, ptr %o, align 32
  invoke void @foo(i32 %3) #5
          to label %invoke.cont unwind label %ehcleanup

invoke.cont:                                      ; preds = %entry
  %4 = call ptr @llvm.localaddress()
  call void @fin_vla_and_realign(i8 0, ptr %4)
  %5 = load ptr, ptr %saved_stack, align 8
  call void @llvm.stackrestore(ptr %5)
  ret void

ehcleanup:                                        ; preds = %entry
  %6 = cleanuppad within none []
  %7 = call ptr @llvm.localaddress()
  call void @fin_vla_and_realign(i8 1, ptr %7) [ "funclet"(token %6) ]
  cleanupret from %6 unwind to caller
}

define void @fin_vla_and_realign(i8 %abnormal_termination, ptr %frame_pointer) {
; CHECK-LABEL: fin_vla_and_realign:
; CHECK:       .seh_proc fin_vla_and_realign
; CHECK-NEXT:  // %bb.0: // %entry
; CHECK-NEXT:    sub sp, sp, #32
; CHECK-NEXT:    .seh_stackalloc 32
; CHECK-NEXT:    str x30, [sp, #16] // 8-byte Folded Spill
; CHECK-NEXT:    .seh_save_reg x30, 16
; CHECK-NEXT:    .seh_endprologue
; CHECK-NEXT:    movz x8, #:abs_g1_s:.Lvla_and_realign$frame_escape_0
; CHECK-NEXT:    movk x8, #:abs_g0_nc:.Lvla_and_realign$frame_escape_0
; CHECK-NEXT:    strb w0, [sp, #15]
; CHECK-NEXT:    ldr w0, [x1, x8]
; CHECK-NEXT:    str x1, [sp, #24]
; CHECK-NEXT:    bl foo
; CHECK-NEXT:    .seh_startepilogue
; CHECK-NEXT:    ldr x30, [sp, #16] // 8-byte Folded Reload
; CHECK-NEXT:    .seh_save_reg x30, 16
; CHECK-NEXT:    add sp, sp, #32
; CHECK-NEXT:    .seh_stackalloc 32
; CHECK-NEXT:    .seh_endepilogue
; CHECK-NEXT:    ret
; CHECK-NEXT:    .seh_endfunclet
; CHECK-NEXT:    .seh_endproc
entry:

  %frame_pointer.addr = alloca ptr, align 8
  %abnormal_termination.addr = alloca i8, align 1
  %0 = call ptr @llvm.localrecover(ptr @vla_and_realign, ptr %frame_pointer, i32 0)
  store ptr %frame_pointer, ptr %frame_pointer.addr, align 8
  store i8 %abnormal_termination, ptr %abnormal_termination.addr, align 1
  %1 = load i32, ptr %0, align 32
  call void @foo(i32 %1)
  ret void
}

declare void @foo(i32)
declare void @llvm.stackrestore(ptr)
declare ptr @llvm.stacksave()
declare ptr @llvm.localrecover(ptr, ptr, i32)
declare ptr @llvm.localaddress()
declare void @llvm.localescape(...)
declare i32 @__C_specific_handler(...)

attributes #0 = { noinline optnone }
